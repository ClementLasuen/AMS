#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import random
import math
# variables
numrep=5
dt=0.1
beta=1.0  # tester pour 300K ou alors beta = 6.67 ou 1.67
nkill=1
# initial points
xi=1.
yi=1.

######## FUNCTIONS ########
# x=pos[0] | y=pos[1]
# V(x,y)=0.2*x**4 + 0.2*(y-1.0/3)**4 + 3*exp(-x**2-(y-1.0/3)**2) - 3*exp(-x**2-(y-5.0/3)**2) - 5*exp(-(x-1)**2-y**2) - 5*exp(-(x+1)**2-y**2

def V(x,y):
	return 0.2*x**4 + 0.2*(y-1.0/3)**4 + 3*math.exp(-x**2-(y-1.0/3)**2) - 3*math.exp(-x**2-(y-5.0/3)**2) - 5*math.exp(-(x-1)**2-y**2) - 5*math.exp(-(x+1)**2-y**2) +4;

# reaction coordinate: returns it for the last point
def reccoord(ind):
	d=0;
	x=rep[ind][-1][0];
	y=rep[ind][-1][1];
	d = math.sqrt( (x-1)**2 + y**2 );
	return 1/d ;# put here the reaction coordinate equation

# returns the zone where the last point of the replica is
def zone(ind):
	# val=-1 if in A
	# rep[ind][-1] est la dernière position de la particule d'indice ind
	val=0
	x=rep[ind][-1][0];
	y=rep[ind][-1][1];
	
	#si on est en A
	if V(x,y)<0.5 and math.sqrt( (x+1)**2 + y**2 ) <= 0.25:
		val = -1;
	else if V(x,y)< 0.5 and math.sqrt( (x-1)**2 + y**2 ) <= 0.25:
		val = 1;
	else :
		val=0;
	# val=1 if in B
	# val=0 if otherwise
	# on definit A et B comme des zones ou le niveau est < quelque chose et proche d'un certain point (pour ne pas confondre A et B)
	return val

# potential derivate
def dPot(pos):
	x=pos[0]
	y=pos[1]
	return [0.8*x**3-6*x*math.exp(-x**2-(y-1./3)**2) +
	        6*x*math.exp(-x**2-(y-5./3)**2) +
                10*(x-1)*math.exp(-(x-1)**2-y**2) +
                10*(x+1)*math.exp(-(x+1)**2-y**2) ,
                0.8*(y-1./3)**3-6*(y-1./3)*math.exp(-x**2-(y-1./3)**2) +
                6*(y-5./3)*math.exp(-x**2-(y-5./3)**2) +
                10*y*math.exp(-(x-1)**2-y**2) +
                10*y*math.exp(-(x+1)**2-y**2)] # put here the potential gradient

# evolution function
def run(ind):
	global rep
	global size
    # evolution for replica ind, return reaction coordinate
	u=random.random()
	v=random.random()
	tgx=math.sqrt(2.*dt/beta)*math.sqrt(-2*math.log(u))*math.cos(2*math.acos(-1)*v)
	tgy=math.sqrt(2.*dt/beta)*math.sqrt(-2*math.log(u))*math.sin(2*math.acos(-1)*v)
	# ref: https://en.wikipedia.org/wiki/Normal_distribution#Generating_values_from_normal_distribution
	tPot=dPot(rep[ind][size[ind]])
	rep[ind].append([rep[ind][size[ind]][0]-dt*tPot[0]+tgx,rep[ind][size[ind]][1]-dt*tPot[1]+tgy])
	size[ind]=size[ind]+1
	return reccoord(ind)

##################################################################
# building the replicas structure
rep=[]
size=[]
level=[]
for i in range(numrep):
	rep.append([[xi,yi]])
	size.append(0)
	level.append(reccoord(i))

# initialization of the replicas
for i in range(numrep):
	while zone(i) == 0:
		where=run(i)
		if where > level[i]:
			level[i]=where
			
def replication(indice,alive_replicas, killing_level): 
	#indice pointe dans rep au replica qui doit être supprimé
	#killing_level est la valeur en-dessous de laquelle on supprime les réplicas
	#ind est l'indice du replica à copier
	#alive_replicas est une liste des replicas 
	new=[]
	ind=random.randint(0,len(alive_replicas)-1)
	coord_reac_new=killing_level-1 #initialisé pour être inférieur à killing_level
	k=0
	while coord_reac_new<killing_level:
		new.append(rep[ind][k])
		coord_reac_new=reccoord(rep[ind][k])
		k+=1
	new.append(rep[ind][k])#point dont la reccoord est >= à killing_level
	#on met à jour level
	level[indice]=reccoord(rep[ind][k])
	#on modifie rep en remplaçant l'ancien replica par le nouveau
	rep[indice]=new
	#on poursuit la trajectoire de la particule correspondant au nouveau replica
	while zone(indice) == 0:
		where=run(indice)
		if where > level[indice]:
			level[i]=where
